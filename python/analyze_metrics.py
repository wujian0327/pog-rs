#!/usr/bin/env python3
"""
Metrics Analysis Script for POG/POS Consensus Comparison

This script reads the CSV files generated by the Rust system and provides
quantitative analysis for comparing Proof-of-Gossip and Proof-of-Stake consensus.
"""

import pandas as pd
import numpy as np
import sys
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns

class MetricsAnalyzer:
    def __init__(self, metrics_dir: Path = Path(".")):
        """Initialize the analyzer with paths to metrics files."""
        self.metrics_dir = Path(metrics_dir)
        self.slot_metrics = None
        self.epoch_metrics = None
        
    def load_metrics(self):
        """Load both slot and epoch metrics from CSV files."""
        slot_file = self.metrics_dir / "metrics_slots.csv"
        epoch_file = self.metrics_dir / "metrics_epochs.csv"
        
        if slot_file.exists():
            self.slot_metrics = pd.read_csv(slot_file)
            print(f"✓ Loaded {len(self.slot_metrics)} slot records")
        else:
            print(f"✗ Slot metrics file not found: {slot_file}")
            
        if epoch_file.exists():
            self.epoch_metrics = pd.read_csv(epoch_file)
            print(f"✓ Loaded {len(self.epoch_metrics)} epoch records")
        else:
            print(f"✗ Epoch metrics file not found: {epoch_file}")
            
    def analyze_slot_metrics(self):
        """Analyze per-slot metrics."""
        if self.slot_metrics is None or len(self.slot_metrics) == 0:
            print("No slot metrics available")
            return
            
        print("\n=== SLOT METRICS ANALYSIS ===")
        print(f"Total slots: {len(self.slot_metrics)}")
        print(f"Total transactions: {self.slot_metrics['tx_count'].sum()}")
        print(f"Avg tx per slot: {self.slot_metrics['tx_count'].mean():.2f}")
        
        print("\nProposer Stake Distribution:")
        print(f"  Min: {self.slot_metrics['proposer_stake'].min():.6f}")
        print(f"  Max: {self.slot_metrics['proposer_stake'].max():.6f}")
        print(f"  Mean: {self.slot_metrics['proposer_stake'].mean():.6f}")
        print(f"  Std: {self.slot_metrics['proposer_stake'].std():.6f}")
        
        print("\nStake Concentration (Herfindahl):")
        print(f"  Min: {self.slot_metrics['stake_concentration'].min():.6f}")
        print(f"  Max: {self.slot_metrics['stake_concentration'].max():.6f}")
        print(f"  Mean: {self.slot_metrics['stake_concentration'].mean():.6f}")
        
        print("\nPath Length Statistics:")
        print(f"  Avg path length mean: {self.slot_metrics['avg_path_length'].mean():.2f}")
        print(f"  Max path length mean: {self.slot_metrics['max_path_length'].mean():.2f}")
        
    def analyze_epoch_metrics(self):
        """Analyze per-epoch metrics."""
        if self.epoch_metrics is None or len(self.epoch_metrics) == 0:
            print("No epoch metrics available")
            return
            
        print("\n=== EPOCH METRICS ANALYSIS ===")
        print(f"Total epochs: {len(self.epoch_metrics)}")
        print(f"Total blocks: {self.epoch_metrics['block_count'].sum()}")
        print(f"Total transactions: {self.epoch_metrics['total_tx'].sum()}")
        
        print("\nThroughput (tx/sec):")
        print(f"  Min: {self.epoch_metrics['throughput_tx_per_sec'].min():.2f}")
        print(f"  Max: {self.epoch_metrics['throughput_tx_per_sec'].max():.2f}")
        print(f"  Mean: {self.epoch_metrics['throughput_tx_per_sec'].mean():.2f}")
        print(f"  Std: {self.epoch_metrics['throughput_tx_per_sec'].std():.2f}")
        
        print("\nBlock Statistics:")
        print(f"  Avg blocks per epoch: {self.epoch_metrics['block_count'].mean():.2f}")
        print(f"  Avg tx per block: {(self.epoch_metrics['total_tx'] / self.epoch_metrics['block_count']).mean():.2f}")
        
        print("\nStake Concentration:")
        print(f"  Min: {self.epoch_metrics['stake_concentration'].min():.6f}")
        print(f"  Max: {self.epoch_metrics['stake_concentration'].max():.6f}")
        print(f"  Mean: {self.epoch_metrics['stake_concentration'].mean():.6f}")
        
    def compare_consensus_types(self):
        """Compare metrics across different consensus types if available."""
        if self.slot_metrics is None or 'consensus_type' not in self.slot_metrics.columns:
            return
            
        print("\n=== CONSENSUS TYPE COMPARISON ===")
        if 'consensus_type' in self.slot_metrics.columns:
            consensus_groups = self.slot_metrics.groupby('consensus_type')
            for consensus_type, group in consensus_groups:
                print(f"\nConsensus: {consensus_type}")
                print(f"  Slots: {len(group)}")
                print(f"  Avg proposer stake: {group['proposer_stake'].mean():.6f}")
                print(f"  Avg stake concentration: {group['stake_concentration'].mean():.6f}")
                print(f"  Avg tx per slot: {group['tx_count'].mean():.2f}")
                
    def generate_plots(self, output_dir: Path = None):
        """Generate visualization plots."""
        if output_dir is None:
            output_dir = self.metrics_dir / "plots"
        output_dir.mkdir(exist_ok=True)
        
        if self.epoch_metrics is not None:
            # Throughput over time
            plt.figure(figsize=(12, 6))
            plt.plot(self.epoch_metrics['epoch'], self.epoch_metrics['throughput_tx_per_sec'])
            plt.xlabel('Epoch')
            plt.ylabel('Throughput (tx/sec)')
            plt.title('Transaction Throughput Over Time')
            plt.grid(True)
            plt.savefig(output_dir / "throughput.png", dpi=150)
            plt.close()
            
            # Stake concentration over time
            plt.figure(figsize=(12, 6))
            plt.plot(self.epoch_metrics['epoch'], self.epoch_metrics['stake_concentration'])
            plt.xlabel('Epoch')
            plt.ylabel('Herfindahl Index')
            plt.title('Stake Concentration Over Time')
            plt.grid(True)
            plt.savefig(output_dir / "stake_concentration.png", dpi=150)
            plt.close()
            
        if self.slot_metrics is not None:
            # Proposer stake distribution
            plt.figure(figsize=(12, 6))
            plt.scatter(self.slot_metrics['slot'], self.slot_metrics['proposer_stake'], alpha=0.6)
            plt.xlabel('Slot')
            plt.ylabel('Proposer Stake')
            plt.title('Proposer Stake Distribution')
            plt.grid(True)
            plt.savefig(output_dir / "proposer_stakes.png", dpi=150)
            plt.close()
            
        print(f"✓ Plots saved to {output_dir}")
        
    def export_summary(self, output_file: Path = None):
        """Export analysis summary to a file."""
        if output_file is None:
            output_file = self.metrics_dir / "metrics_summary.txt"
            
        with open(output_file, 'w') as f:
            f.write("POG/POS CONSENSUS METRICS ANALYSIS SUMMARY\n")
            f.write("=" * 50 + "\n\n")
            
            if self.slot_metrics is not None:
                f.write("SLOT METRICS\n")
                f.write("-" * 30 + "\n")
                f.write(self.slot_metrics.describe().to_string())
                f.write("\n\n")
                
            if self.epoch_metrics is not None:
                f.write("EPOCH METRICS\n")
                f.write("-" * 30 + "\n")
                f.write(self.epoch_metrics.describe().to_string())
                f.write("\n\n")
                
        print(f"✓ Summary exported to {output_file}")

def main():
    """Main entry point."""
    if len(sys.argv) > 1:
        metrics_dir = Path(sys.argv[1])
    else:
        metrics_dir = Path(".")
        
    analyzer = MetricsAnalyzer(metrics_dir)
    analyzer.load_metrics()
    analyzer.analyze_slot_metrics()
    analyzer.analyze_epoch_metrics()
    analyzer.compare_consensus_types()
    
    try:
        analyzer.generate_plots()
    except ImportError:
        print("(Matplotlib not available for plots)")
        
    analyzer.export_summary()
    print("\n✓ Analysis complete!")

if __name__ == "__main__":
    main()
